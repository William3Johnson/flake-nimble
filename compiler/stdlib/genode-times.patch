diff --git a/lib/pure/times.nim b/lib/pure/times.nim
index f255bdd42..6823f7dfb 100644
--- a/lib/pure/times.nim
+++ b/lib/pure/times.nim
@@ -256,6 +256,29 @@ elif defined(windows):
 
   proc localtime(a1: var CTime): ptr Tm {.importc, header: "<time.h>".}
 
+elif defined(genode):
+  include genode/env
+  const rtcHeader = "<rtc_session/connection.h>"
+
+  type
+    Timestamp {.importcpp: "Rtc::Timestamp", header: rtcHeader, final, pure.} = object
+      microsecond*: cuint
+      second*: cuint
+      minute*: cuint
+      hour*: cuint
+      day*: cuint
+      month*: cuint
+      year*: cuint
+
+  proc rtcCurrentTime(): Timestamp =
+    type RtcConnection {.importcpp: "Rtc::Connection", header: rtcHeader, final, pure.} = object
+    proc connectRtc(env: GenodeEnvPtr; label: cstring): RtcConnection {.
+      importcpp: "RtcConnection(*#, #)", constructor.}
+    proc current_time(rtc: RtcConnection): Timestamp {.importcpp.}
+    let session = runtimeEnv.connectRtc("Nim runtime")
+      # is this labeling useful?
+    session.current_time();
+
 type
   Month* = enum ## Represents a month. Note that the enum starts at ``1``,
                 ## so ``ord(month)`` will give the month number in the
@@ -1095,6 +1118,22 @@ when defined(JS):
     result.time = adjTime + initDuration(seconds = result.utcOffset)
     result.isDst = false
 
+elif defined(genode):
+  proc toEpochSeconds(ts: Timestamp): int64 =
+    let
+      ts = rtcCurrentTime()
+      epochDay = toEpochDay(ts.day, ts.month.Month, ts.year.int)
+    result = epochDay * secondsInDay
+    result.inc ts.hour.int * secondsInHour
+    result.inc ts.minute.int * 60
+    result.inc ts.second.int
+
+  proc localZonedTimeFromTime(time: Time): ZonedTime =
+    discard
+
+  proc localZonedTimeFromAdjTime(adjTime: Time): ZonedTime =
+    discard
+
 else:
   proc toAdjUnix(tm: Tm): int64 =
     let epochDay = toEpochDay(tm.tm_mday, (tm.tm_mon + 1).Month,
@@ -1211,6 +1250,12 @@ proc getTime*(): Time {.tags: [TimeEffect], benign.} =
     gettimeofday(a)
     result = initTime(a.tv_sec.int64,
                       convert(Microseconds, Nanoseconds, a.tv_usec.int))
+  elif defined(genode):
+    let ts = rtcCurrentTime()
+    result.seconds = ts.toEpochSeconds
+    result.nanosecond = ts.microsecond.int  div 1_000
+      # TODO: need a timer session for actual sub-second accuracy
+
   elif defined(posix):
     var ts: Timespec
     discard clock_gettime(CLOCK_REALTIME, ts)
@@ -2557,6 +2602,9 @@ when not defined(JS):
       var secs = i64 div rateDiff
       var subsecs = i64 mod rateDiff
       result = toFloat(int(secs)) + toFloat(int(subsecs)) * 0.0000001
+    elif defined(genode):
+      let ts = rtcCurrentTime()
+      ts.toEpochSeconds.float + (ts.microsecond.float / 1_000_000.0)
     else:
       {.error: "unknown OS".}
 
@@ -2665,7 +2713,7 @@ proc fractional*(dur: Duration): Duration {.inline, deprecated.} =
         nanoseconds = 9)
   initDuration(nanoseconds = dur.nanosecond)
 
-when not defined(JS):
+when not defined(JS) and not defined(Genode):
   proc unixTimeToWinTime*(time: CTime): int64
       {.deprecated: "Use toWinTime instead".} =
     ## Converts a UNIX `Time` (``time_t``) to a Windows file time
@@ -2738,6 +2786,9 @@ proc getTimezone*(): int
     # This is wrong since it will include DST offsets, but the behavior has
     # always been wrong for bsd and the proc is deprecated so lets ignore it.
     return now().utcOffset
+  elif defined(genode):
+    echo "no timezone information available for this platform"
+    quit -1
   else:
     return timezone
 
